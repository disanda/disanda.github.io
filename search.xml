<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[对当下高职教育的个人感想]]></title>
    <url>%2F2018%2F07%2F20%2F%E5%AF%B9%E5%BD%93%E4%B8%8B%E9%AB%98%E8%81%8C%E6%95%99%E8%82%B2%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[对当下高职教育，学历提升和上升通道的思考 说到教育，先谈一谈我们教育一件最重要的事 高考 不可否认，高考是当下我国最重要的考试，没有之一，无数人因此踏实不同的人生道路，去不同的城市，不同的大学，不同的专业，迎接不同的人生。 高考也是人生的第一次分水岭，十年磨一剑，去了一流大学的人，相对得到更好的资源和平台，也就是更好的发展，事实证明，这是大概率的情况。 对于一般本科的学生而言，相对前者有一个质的差距，无论就业的机会，还是学校四年的机会和经历，举例。外交部等部委到学校的直接招聘，海外和国内名校的保送名额，还有跨国企业的招聘，无论就业岗位和层次，都会有差距。 当然，从高考的选拔角度来说，应试能力和个人实力造成了这样的差距，公平竞争，通过高考选拔人才，这无可厚非。但我们不能忽略个人努力的在不同时期的差异。 无论高考结果与否，我认为，只要一个人在任何时刻省悟，并投入努力去拼搏，就应该有改变命运的机会。 出国&amp;考研 考研总的来说给了当下普通本科生一次“再高考”的机会，很多人，都是这个机会的受益者。通过考研，相对公平的考试和选拔制度，让大量人以“追求学术的名义”从新选择高校，从而进入名校，得到较好学校的就业和发展机会。 我无意笃定高考和考研的决定性，但它的重要性在当下中国具有普世意义。我承认，高考不理想或未考研的学生中不乏优秀成功的人，但按比例和趋势看，这不具有普片意义，对大部分人来说，还是高考和考研提高了他们就业和发展的可能性，完成了一次质变。 以上说的，是客观问题。机会有了，成功与否很大程度上是个人努力决定的。高考成功，考研成功等等成功，机会只是一方面。但对于高职学生来说，这样的机会现在闲的有点少。 高职教育 高职学生和大部分本科学生一样，同样的年龄，同样的体制和教育后开始新的旅程。 在这样一个大好年纪，无论处于任何一个环境和学历，人都有提高自己，追求更好生活的权力，更何况相对本科处于劣势的高职学生，特别那些优秀的高职学生。 然而现在的情况并没有这样的机会，一方面，专升本的考试升学率一直在降低，专生本并没有太多的学校可以选择，且不能出省，这意味着专科教育就是针对本地为本地中小企业服务的教育，虽然专科教育按学生能力和社会需求，这样的定位并没有什么问题，但缺少上升的路径。 但人生而平等，广大专科生是否能有类似考研的机会呢？ 这机会意味着什么？ 我想一个优秀的高职学生，也可能会有改变努力命运的想法，如通过努力学习，去更好的大学，感受一下大学的生活和教育，有更好的平台和人生，去其他城市，从南到北，离开家乡去看看，闯一闯，趁年轻，看看外面的世界。 我的感想和建议 给高职学生一个这样的机会，在物质生活日益丰盛的今天，文化和精神的需求变得更为强烈，国家发展也处理向劳动密集型向科研创新性转变，需要这样的机会，整体提高高等教育水平。 当下的高职学生，就我一线的从教感受而言，也对专升本考试日益重视，他们知道这个的意义和重要性，有一份人本该有的渴望和梦想。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>高职教育</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0.算法分类]]></title>
    <url>%2F2018%2F06%2F06%2F%E7%AE%97%E6%B3%95%2Fp%20np%20npc%2F</url>
    <content type="text"><![CDATA[原创 进阶算法概述 算法分类(多项式分类) P问题 如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题。 P是英文单词多项式的第一个字母。 NP问题 NP问题不是非P类问题。NP问题是指可以在多项式的时间里验证一个解的问题。 NP问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。 NP问题一直都是信息学的巅峰。巅峰，意即很引人注目但难以解决。在信息学研究中，这是一个耗费了很多时间和精力也没有解决的终极问题，好比物理学中的大统一和数学中的歌德巴赫猜想等。 目前为止这个问题还“啃不动”。但是，一个总的趋势、一个大方向是有的。人们普遍认为，P=NP不成立，也就是说，多数人相信，存在至少一个不可能有多项式级复杂度的算法的NP问题。人们如此坚信P≠NP是有原因的，就是在研究NP问题的过程中找出了一类非常特殊的NP问题叫做NP-完全问题，也即所谓的 NPC问题。C是英文单词“完全”的第一个字母。正是NPC问题的存在，使人们相信P≠NP。 NP-hard P!=NP时，NP-hard属于比NP难的问题,只可以用一定运算（时间大于等于多项式运算时间）解决该问题，无法找到多项式的算法。 P=NP时，NP=NP-hard NPC问题 约化(Reducibility，有的资料上叫“归约”) : 一个问题A可以约化为问题B的含义即是，可以用问题B的解法解决问题A 参见《算法导论》：一元二次方程解一元一次方程的例子 一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。 通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。 再回想前面讲的P和NP问题，根据约化的传递性，如果不断地约化上去，不断找到能“通吃”若干小NP问题的一个稍复杂的大NP问题，那么最后能找到一个时间复杂度最高，并且能“通吃”所有的NP问题的这样一个超级NP问题，就是NPC问题。 只要解决了这个NPC问题，那么所有的NP问题都解决了。这种问题不只一个，它有很多个，它是一类问题。这一类问题就是传说中的NPC问题，也就是NP-完全问题。 NPC问题：a.它得是一个NP问题；b.所有的NP问题都可以约化到它。 （证明一个问题是 NPC问题也很简单。先证明它至少是一个NP问题，再证明其中一个已知的NPC问题能约化到它 常见NPC问题SAT问题0-1整数规划最大团ClIQUE顶点覆盖问题子集合问题哈密顿回路问题TSP问题http://www.matrix67.com/blog/archives/105]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三.贪心算法]]></title>
    <url>%2F2018%2F06%2F06%2F%E7%AE%97%E6%B3%95%2F3%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[原创 进阶算法概述 1.算法本质 在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。 贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 2.解题步骤类似一个一维数组遍历，每一步遍历都能获得局部最优解，每一次只考虑选取一个数据，它满足当时局部最优解。 伪代码 一般是一个双重循环，第一重循环是总循环，第二重循环是每次循环求局部最优解 3.例题 其他 贪心算法 贪心算法的本质：从问题的某一个初始解出发，向给定的目标推进。推进的每一步做一个当时看似最佳的贪心选择。不断的将问题规模缩小。并由所有的局部最优选择产生一个全局最优解 删数问题 从键盘输入一个高精度正整数N(N不超过200位），任意去掉S个数字，把剩下的数字组合成一个新的正整数，次序不变且剩下的数字组成的新数最小。输入：N（≤200位），S（1≤S≤10）例如： 输入 51428397 5 输出 123 代码(python) 123456789101112131415161718192021# 命令行输入输出# 删数问题print(&quot;输入一个整数&quot;)a = input()print(&quot;输入删除的位数&quot;)b = input()b = int(b)n = len(a) for i in range(b): x=len(a) for j in range(x): if (j+1)&lt;x: if a[j] &gt; a[j+1]: a = a[:j]+a[j+1:] break else: a = a[:j] breakprint(a) 首先：N超过200位，肯定要用字符串数组来进行存储。我们知道字符串数组隐含的’\0’作为结束符。当然，我们也可以用strlen()函数来直接计算字符串长度。 第二步，如何删除数字。假定只删除一个数字。如果数字从左到右为顺序增大，显然删除最后一个可以。如果不是顺序增加的。删除递减区间的第一个就行了。这样循环删除s个数字即可完成。 还要注意一点的是，每删除一个数字，就要从这个数组的第一个单元开始重新判断。所以，用当型循环比较合适。每判断到一个可以删除的数，就结束判断。 https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741375.html]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二.动态规划]]></title>
    <url>%2F2018%2F06%2F06%2F%E7%AE%97%E6%B3%95%2F2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[原创 进阶算法概述 二.动态规划1.算法本质 状态 一个方程，用于表述问题的(1-n)通向公式，可以是求解过程中一个开始或一个结果 状态转移方程 状态与状态的关系公式，就是转移方程,比如状态k和状态k-1 2.解题步骤 二维数组填表 状态与状态的转移用一张二维表来表述，通过双重循环来逐渐把二维表填满，表每一行是一个状态，下一行是转移到另一个状态，最终填满二维表 3.例题3.1 0-1背包问题 问题描述 有N件物品和一个容量为==v==的背包。第i件物品的重量是==c[i]==(每一件物品只有一件，可以选择装或者不装，也就是问题0-1的意思)，价值是==w[i]==。求解将哪些物品装入背包可使价值总和最大。 状态 即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。 转移方程 1f[i][v]=max&#123;f[i-1][v],f[i-1][v-c[i]]+w[i]&#125; 伪代码 123456#c[i]=cost[i],w[i]=weight[i]for i=1..N for v=V..0 f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; 3.2 TSP问题 问题描述 Travelling Salesman Problem (TSP) 是最基本的路线问题。它寻求的是旅行者由起点出发，通过所有给定的需求点后，再次返回起点所花费的最小路径成本 状态 d(i,v)表示从顶点i出发，经过v中所有结点一次后的最小花费 转移方程 $d(i,v)=min_{i\epsilon{v}}\{d(k,v)+c_{ki}\}$ 代码 123456789101112131415161718for(int j=1;j&lt;1&lt;&lt;(n-1);j++)&#123; for(int i=1;i&lt;n;i++)&#123; //j用二进制表示的城市集合 if(((1&lt;&lt;(i-1))&amp;j)==0)&#123; //i不在j表示的城市集合中 minDis=60000; for(int k=1;k&lt;n;k++)&#123; if(((1&lt;&lt;(k-1))&amp;j)!=0) &#123;//k表示的城市在j表示的城市集合中 temp=dis[i][k]+d[k][j-(1&lt;&lt;(k-1))]; if(temp&lt;minDis)&#123; minDis=temp; //所有k中最小的距离 &#125; &#125; &#125; &#125; d[i][j]=minDis; &#125; &#125; 其他动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。 动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。 与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。 如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一.分冶算法]]></title>
    <url>%2F2018%2F06%2F06%2F%E7%AE%97%E6%B3%95%2F1%E5%88%86%E5%86%B6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[原创 进阶算法概述 一.分冶算法1.算法本质 一个问题规模为N的问题可以分解为k个规模较小的问题，这些子问题相互独立且与原问题性质相同，求出子问题的解可以得到原问题的解。 2.算法步骤 分解 求解（子问题比原问题易求） 合并 2.1 伪代码 伪代码 1234567891011121314151617181920212223242526分治法的伪代码： v divide_and_conquer(proplem p) &#123;//n为问题规模 if(|p|&lt;n0)//n0为一阈值 solve(p); else &#123; divide p into smaller subproblem P1,P2,...Pk; for(i=1;i&lt;=k;i++) &#123; yi=divide_and_conquer(Pi); #可能用到递归 return merge(y1,y2,...,yk); &#125; &#125; &#125; 3.例题(python)3.1求众数(一个数组中重复最多的数) 思想 （1）快速排序 （2）求中位数,及其重数(重复数) （3）计算出中位数的最左端和最右端的位置(如果有重复)，然后分割成2段数组 （4）中位数个数与左端数组个数比较，中&lt;左 即最大众数可能存在左端，将左端再进行2段分割（递归）直到 中 &gt; 左为止 代码 12345678910def mode(l,r) #l,r两个参数分别代表数组两端，a是数组 med = median(a,l,r) //寻找中位数 split = (a,med,l,r,l1,r1)//分割数组 if largest&lt;(r1-l1+1): largest=r1-l1+1 element=med;//element是众数 if(l1-1&gt;largest): mode(1,l1-1) if(r-r1&gt;largest): mode(r1+1,r) 3.2 合并排序 基本思想:将一组数分为两组数，分别对两组数进行排序，将合并好的子集合合并到排好序的集合中 1234567891011void MergeSort(Type a[],int left,int right)&#123; if(left &lt; right) &#123; int i = (left + right)/2 &#125; MergeSort(a,left,i) MergeSort(a,i+1,right) Merge(a,b,left,i,right)//合并数组到b Copy(a,b,left,right)//复制回数组a&#125; 3.3 快速排序12345678910111213141516def Qsort(a,left,right): l = left r = right key = a[0] while(l&lt;r): while(l&lt;r &amp;&amp; a[r]&gt;=key): r = r-1 a[l] = a[r] while(l&lt;r &amp;&amp; a[l]&lt;=key): l = l+1 a[r] = a[l] a[0]= key Qsort(a,left,l-1) Qsort(a,l+1,right)Qsort(a,0,len(a-1)) 3.4 重复元素排列问题 思想 n个元素的全排列减小的n-1个元素的全排列，直至减小的1个元素的排列，就不需要排列 其他分治法所能解决的问题一般具有以下几个特征： 1) 该问题的规模缩小到一定的程度就可以容易地解决 2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。 3) 利用该问题分解出的子问题的解可以合并为该问题的解； 4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。 第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加； 第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用； 第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。 第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。 http://blog.jobbole.com/83944/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五.分支限界]]></title>
    <url>%2F2018%2F06%2F06%2F%E7%AE%97%E6%B3%95%2F5%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%2F</url>
    <content type="text"><![CDATA[原创 进阶算法概述 五.回溯算法1.算法本质 求解目标：回溯法的求解目标是找出解空间树中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解。 求解思路:在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所需的解或活结点表为空时为止 2.算法步骤 利用一个队列，进行对树或图的广度优先遍历 伪代码 12345678910111213141516q = queue()q.put(s) # 插入原点v[s][s] = 0def f(x): while true: i=q.get() if !q.empty() : j=q.pull() #出队 v[s][j]=v[s][j-1]+s.value() if i != x: while s.next(): q.put(s.next()) #入队 else: break;f(x)print(min(v[s][x])) 3.典型应用3.1 单源最短路径3.2 TSP问题]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四.回溯算法]]></title>
    <url>%2F2018%2F06%2F06%2F%E7%AE%97%E6%B3%95%2F4%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[原创 进阶算法概述 四.回溯算法1.算法本质 解决多选择问题 选择时判断，符合条件继续，不符合条件返回 把问题的解空间转化成了图(深度优先)或者树(左右根)的结构表示。 2.算法步骤2.1 算法基本的步骤思想为： 在搜索过程中动态产生问题的解空间 只保存从根结点到当前扩张结点的路径 深度优先方式搜索解空间，能找出满足约束条件的所有解 2.2 伪代码:12345678def Backtrack(t) if t&gt;n : output(x) #记录可行解 else: for i in ResultTree X[t] = h(i) # h(i)表示当前结点处的第i个可选值 if constraint(t)&amp;&amp;bount(t) #解空间的约束函数和限界函数 Backtrack(t+1) 3.回溯算法应用3.1 八皇后问题 八皇后问题是一个以国际象棋为背景的问题：如何能够在 8×8 的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？ 为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。八皇后问题可以推广为更一般的n皇后摆放问题：这时棋盘的大小变为n×n，而皇后个数也变成n。当且仅当 n = 1 或 n ≥ 4 时问题有解 Input 无输入 Output 多种 123456789101112131415161718192021222324252627No. 11 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 No. 21 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 No. 31 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 求解思路 观察棋盘坐标 同一斜线上的“/”上的坐标点，横纵坐标之和相同 同一斜线上的“\”上的坐标点，横纵坐标之差相同 基本步骤 判断皇后冲突 递归得到结果 输出所有结果 代码 1234567891011121314151617181920212223242526272829# state是一个元组，存放每行的坐标,从首行开始# pos是当前行不与之前皇后冲突的位置&gt;&gt;&gt; def confict(state, pos): nextY = len(state) if pos in state: return True &apos;&apos;&apos;判断斜线&apos;&apos;&apos; for i in range(nextY): if nextY-pos == i-state[i]: return True if nextY+pos == i+state[i]: return True return False&gt;&gt;&gt; def queens(num, state=()): if num-1 == len(state): #若当前是最后一次选择 for i in range(num): #遍历选择的所有值，此次选择不与前值冲突，以元祖形式返回该值 if not confict(state, i): yield (i,) else: for pos in range(num): #当前不是最后一次选择： #遍历所有取值，若不与之前的选择序列冲突， #“返回”当前选择取该值的基础上，接来的选择结果。 if not confict(state, pos): for result in queens(num, state+(pos,)): yield (pos,) + result &gt;&gt;&gt; for i in list(queens(8)): print(i) 3.2 数独问题3.3 集合问题3.4 图着色问题]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教程2 Django 操作Mysql(增加数据)]]></title>
    <url>%2F2018%2F05%2F03%2Fdjango%2FA%20mysql%E6%93%8D%E4%BD%9C%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Django框架,以MVT(mvc+T)模式高效开发web,超越spring系列的存在 Django 操作Mysql(增加数据)版本 Django:2.0.5 Python:3 Mysql:5.7.20 PyMySQL:0.8.0 一、配置数据库(包括model层) settings.py文件 1.配置mysql连接123456789101112DATABASES = &#123; &apos;default&apos;: &#123; #&apos;ENGINE&apos;: &apos;django.db.backends.sqlite3&apos;, #&apos;NAME&apos;: os.path.join(BASE_DIR, &apos;db.sqlite3&apos;), &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &apos;testdata&apos;, &apos;USER&apos;: &apos;root&apos;, &apos;PASSWORD&apos;: &apos;xxxxx&apos;, #数据库密码 &apos;HOST&apos;: &apos;127.0.0.1&apos;, &apos;PORT&apos;: &apos;3306&apos; &#125;&#125; 2.注册app 先在命令行生成app 1&gt;python manage.py startapp appname 再在配置文件中配置123456789INSTALLED_APPS = [ &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &apos;appname&apos; #最后一行加上app名] models.py 定义models.py中的类 12345678910 # -*- coding: utf-8 -*-from __future__ import unicode_literalsfrom django.db import models# Create your models here.class message(models.Model): username = models.CharField(max_length=20) password = models.CharField(max_length=15) 数据库操作(models-&gt;mysql) 1.pymysql 区别于python2，python3中没有MysqlDB,所以python3不能连接到数据库，会报错”no modul MysqlDB”,替代包有pyMySQL,Mysqlclient. 在站点文件中的init.py中导入12import pymysqlpymysql.install_as_MySQLdb() 2.命令行操作 生成数据库迁移类1python manage.py makemigrations appname 把迁移类迁移到数据库1python manage.py migrate 数据库操作 迁移前123&gt;mysql -u root -p;&gt;password;&gt;create database testdata; 迁移后 12345&gt;show databases;&gt;use testdata;&gt;show tables;&gt;desc appname_message #查看同步的数据表结构&gt;select * from appname_message #查看数据表结构 二、view层 views.py文件 导入包 123from __future__ import unicode_literalsfrom appname import modelsfrom django.shortcuts import render_to_response 定义insert函数，用于将网页数据插入到数据库123456def insert(request): if request.method == &quot;POST&quot;: username = request.POST.get(&quot;username&quot;, None) password = request.POST.get(&quot;password&quot;, None) models.message.objects.create(username=username, password=password) return render_to_response(&apos;insert.html&apos;) 定义list函数,用于将数据库数据显示到网页 123def list(request): people_list = models.message.objects.all() return render_to_response(&quot;showuser.html&quot;,&#123;&quot;people_list&quot;:people_list&#125;) 三、control层(urls.py) 控制访问路径123456789from django.conf.urls import urlfrom django.contrib import adminfrom appname import viewsurlpatterns = [ url(r&apos;^insert/&apos;,views.insert), url(r&apos;^show/&apos;,views.list), url(r&apos;^admin/&apos;, admin.site.urls),] 四、网页部分(templates) 在根文件夹下创建templates文件夹,并在setting.py中配置TEMPLATES的’DIRS’ 12345678910111213141516TEMPLATES = [ &#123; &apos;BACKEND&apos;: &apos;django.template.backends.django.DjangoTemplates&apos;, &apos;DIRS&apos;: [os.path.join(BASE_DIR,&apos;templates&apos;)], #配置templates的路径 &apos;APP_DIRS&apos;: True, &apos;OPTIONS&apos;: &#123; &apos;context_processors&apos;: [ &apos;django.template.context_processors.debug&apos;, &apos;django.template.context_processors.request&apos;, &apos;django.contrib.auth.context_processors.auth&apos;, &apos;django.contrib.messages.context_processors.messages&apos;, ], &#125;, &#125;,] 插入数据页面insert.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;用户登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;/insert/&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 显示数据页面showuser.html 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;信息展示&lt;/h1&gt; &lt;table &lt;tr&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;密码&lt;/th&gt; &lt;/tr&gt; &#123;% for line in people_list %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;line.username&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;line.password&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 五、其他 页面提交数据报错(403)，在setting.py中关闭CSRF 123456789MIDDLEWARE = [ &apos;django.middleware.security.SecurityMiddleware&apos;, &apos;django.contrib.sessions.middleware.SessionMiddleware&apos;, &apos;django.middleware.common.CommonMiddleware&apos;, #&apos;django.middleware.csrf.CsrfViewMiddleware&apos;, &apos;django.contrib.auth.middleware.AuthenticationMiddleware&apos;, &apos;django.contrib.messages.middleware.MessageMiddleware&apos;, &apos;django.middleware.clickjacking.XFrameOptionsMiddleware&apos;,] -参考: https://blog.csdn.net/yf999573/article/details/53081196 https://blog.csdn.net/it_dream_er/article/details/52093362]]></content>
      <categories>
        <category>Django框架</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教程3 Django操作Mysql(删除、修改数据)]]></title>
    <url>%2F2018%2F05%2F03%2Fdjango%2FA%20mysql%E6%93%8D%E4%BD%9C%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Django框架,以MVT(mvc+T)模式高效开发web,超越spring系列的存在 Django操作Mysql(删除、修改数据)一.前期工作 生成app 命令行输入1&gt;python manage.py startapp webname 配置setting.py 123456789101112131415161718192021222324#数据库DATABASES = &#123; &apos;default&apos;: &#123; #&apos;ENGINE&apos;: &apos;django.db.backends.sqlite3&apos;, #&apos;NAME&apos;: os.path.join(BASE_DIR, &apos;db.sqlite3&apos;), &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &apos;testdata2&apos;, &apos;USER&apos;: &apos;root&apos;, &apos;PASSWORD&apos;: &apos;121212&apos;, #数据库密码 &apos;HOST&apos;: &apos;127.0.0.1&apos;, &apos;PORT&apos;: &apos;3306&apos; &#125;&#125;#注册appINSTALLED_APPS = [ &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &apos;web&apos;,] 配置init.py 123# 先安装pymysql包import pymysqlpymysql.install_as_MySQLdb() 二.MVC配置 model层(models.py) 建几个类就对应几张表 123456789101112131415from django.db import models# Create your models here.class Classes(models.Model): titile = models.CharField(max_length=32) m = models.ManyToManyField(&quot;Teachers&quot;)class Teachers(models.Model): name = models.CharField (max_length=32)class Student(models.Model): username = models.CharField(max_length=32) age = models.IntegerField() gender = models.BooleanField() cs = models.ForeignKey(Classes,on_delete=models.CASCADE,) views层(views.py) 先把views.py删除,用一个文件夹views替代，在文件夹下建立classes.py、students.py、teachers.py三个文件,分别代表三个视图 123456789101112131415161718192021222324252627282930313233343536#其中classes.py如下:from django.shortcuts import renderfrom django.shortcuts import redirectfrom web import modelsdef get_classes(request): cls_list = models.Classes.objects.all() return render(request, &apos;get_classes.html&apos;, &#123;&apos;cls_list&apos;: cls_list&#125;)def add_classes(request): if request.method == &quot;GET&quot;: return render(request, &apos;add_classes.html&apos;) elif request.method == &apos;POST&apos;: title = request.POST.get(&apos;titile&apos;) models.Classes.objects.create(titile=title) return redirect(&apos;/get_classes.html&apos;)def del_classes(request): nid = request.GET.get(&apos;nid&apos;) models.Classes.objects.filter(id=nid).delete() return redirect(&apos;/get_classes.html&apos;)def edit_classes(request): if request.method == &apos;GET&apos;: nid = request.GET.get(&apos;nid&apos;) obj = models.Classes.objects.filter(id=nid).first() return render(request, &apos;edit_classes.html&apos;, &#123;&apos;obj&apos;: obj&#125;) elif request.method == &apos;POST&apos;: nid = request.GET.get(&apos;nid&apos;) title = request.POST.get(&apos;title&apos;) models.Classes.objects.filter(id=nid).update(titile=title) return redirect(&apos;/get_classes.html&apos;) control层(urls.py文件) 123456789101112from django.conf.urls import urlfrom django.contrib import adminfrom web.views import classesurlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), url(r&apos;^get_classes.html$&apos;, classes.get_classes), url(r&apos;^add_classes.html$&apos;, classes.add_classes), url(r&apos;^del_classes.html$&apos;, classes.del_classes), url(r&apos;^edit_classes.html$&apos;, classes.edit_classes), url(r&apos;&apos;,classes.get_classes),#首页默认页面] 三、模版层(templates) 先创建templates文件夹，在settings.py设置templates文件夹路径(参考上一讲) get_classes.html 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;a href=&quot;/add_classes.html&quot;&gt;添加&lt;/a&gt;&lt;/div&gt;&lt;div&gt; &lt;table border=&quot;1&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for row in cls_list %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; row.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; row.titile &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;/del_classes.html?nid=&#123;&#123; row.id &#125;&#125;&quot;&gt;删除&lt;/a&gt; | &lt;a href=&quot;/edit_classes.html?nid=&#123;&#123; row.id &#125;&#125;&quot;&gt;编辑&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; add_classes.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;add_classes.html&quot; method=&quot;POST&quot;&gt; &#123;% csrf_token %&#125; &lt;input type=&quot;text&quot; name=&quot;titile&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; edit_classes.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt; &lt;form action=&quot;/edit_classes.html?nid=&#123;&#123; obj.id &#125;&#125;&quot; method=&quot;POST&quot;&gt; &#123;% csrf_token %&#125; &lt;input type=&quot;text&quot; name=&quot;title&quot; value=&quot;&#123;&#123; obj.titile &#125;&#125;&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 四、其他 同步到数据库操作 命令行两步操作 123&gt;python manage.py makemigrate webname #输出modles到数据库到中间文件&gt;python namge.py migrate #同步到数据库 参考https://www.cnblogs.com/nulige/p/6529175.html]]></content>
      <categories>
        <category>Django框架</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教程1 Django初学实践，创建简易blog]]></title>
    <url>%2F2018%2F05%2F03%2Fdjango%2FA%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B(%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2)%2F</url>
    <content type="text"><![CDATA[Django框架,以MVT(mvc+T)模式高效开发web,超越spring系列的存在 1.前期工作 创建项目 1django-admin.py startproject mysite 运行服务器 1python manage.py runserver 创建应用(app) 1python manage.py startapp blog 2.mvc设计 models(models.py)用于定义数据结构 1234567891011121314from __future__ import unicode_literalsfrom django.contrib import adminfrom django.db import modelsclass BlogPost(models.Model): title = models.CharField(max_length =150) body = models.TextField() timestamp = models.DateTimeField()# BlogPost类是django.db.models.Model的一个子类 。#它有变量title(blog的标题)，body(blog的内容部分)，#timestamp(blog的发表时间)。 class BlogPostAdmin(admin.ModelAdmin): list_display = (&apos;title&apos;,&apos;timestamp&apos;) views(views.py) 该层用于定义request和response，就是用户请求后获得什么样的页面 123456789from blog.models import BlogPostfrom django.shortcuts import render_to_responsedef myBlogs(request): blog_list = BlogPost.objects.all() return render_to_response(&apos;BlogTemplate.html&apos;,&#123;&apos;blog_list&apos;:blog_list&#125;)def Hello(request): return HttpResponse(&apos;&lt;h1&gt;hello disanda&lt;h1&gt;&apos;) controller(urls.py) 123456789from django.conf.urls import urlfrom django.contrib import adminfrom blog.views import *urlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), url(r&apos;^myBlogs/$&apos;,myBlogs), url(&apos;&apos;,Hello) ] 3.templates模版网站(MTV模式)基模版页123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;标题&lt;/title&gt;&lt;/head&gt;&lt;style type=&quot;text/css&quot;&gt; body&#123; color: #efd; background: #BBBBBB; padding: 12px 5em; margin:7px; &#125; h1&#123; padding: 2em; background: #675; &#125; h2&#123; color: #85F2F2; border-top: 1px dotted #fff; margin-top:2em; &#125; p&#123; margin:1em 0; &#125;&lt;/style&gt;&lt;body&gt;&lt;h1&gt;XX博文&lt;/h1&gt;&lt;h3&gt;小生不才，但求简约！&lt;/h3&gt;&#123;% block content %&#125;&#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; 具体网页(和views.py中的网页对应)12345678910BlogTemplate.html&#123;% extends &quot;base.html&quot; %&#125; &#123;% block content %&#125; &#123;% for post in blog_list %&#125; &lt;h2&gt;&#123;&#123; post.title &#125;&#125;&lt;/h2&gt; &lt;p&gt;&#123;&#123; post.timestamp &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; post.body &#125;&#125;&lt;/p&gt; &#123;% endfor %&#125; &#123;% endblock %&#125; 4.配置工作2.1前期配置 在setting.py的INSTALLED_APP列表中配置app 123456789INSTALLED_APPS = ( &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &apos;blog&apos;,) 在setting.py中配置数据库连接 2.2 model相关(写完model之后) 记录model变动 完成后会生成model中对应类的文件 1python manage.py makemigrations 同步数据库 1python manage.py migrate 创建超级管理员 1python manage.py createsuperuser 在admin.py中注册model模型中的类 12from blogapp.models import BlogPostadmin.site.register(BlogPost)]]></content>
      <categories>
        <category>Django框架</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.2 字符串]]></title>
    <url>%2F2018%2F02%2F02%2FPython%2F1.2%20%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[继第一章 1.2.4 字符串的其他操作分割字符串split() 12345678s1 = &apos;a:b&apos;x,y=s.split(&apos;:&apos;)s2 = &apos;a:b:c&apos;x,y,z=s.split(&apos;:&apos;,2) #第二个参数代表两个分割(分为三个部分)，默认是一个分割xyz 列表插入函数,join() 12345678#&apos;x&apos;.join(list)#表示把x插入到list的每个元素之间，形成一个字符串#1x3 =[&apos;1&apos;,&apos;a&apos;,&apos;b&apos;,&apos;2&apos;]y3 =&apos;&apos;.join(x3)y3&gt;&gt;&gt; &apos;1ab2&apos; #输出字符串]]></content>
      <categories>
        <category>Python教程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3. Python函数]]></title>
    <url>%2F2017%2F12%2F02%2FPython%2F3.%20%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[第三章 函数 Python原创教程，持续更新 3.1 函数本质函数，也称方法，是一系列运算集合,一个函数本质由以下要素构成: 名字 参数 运算流程(方法体内) 返回值 其中参数和返回值是可选的1234567891011121314151617181920# 无参数，无返回值def fun1(): print(&quot;hello world&quot;)# 有两个参数x，ydef fun2(x,y): z=x+y print(z) # 无参数，有返回值 def fun3(): z=100 return z # 有参数，有返回值(最常见的函数)def fun4(x,y,z): w=x+y*z return w]]></content>
      <categories>
        <category>Python教程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.Python变量]]></title>
    <url>%2F2017%2F12%2F01%2FPython%2F1.%20Python%20%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Python原创教程，持续更新 第一章 变量1.1 前言变量是编程语言存储数据的方式，python中定义变量不需要声明类型（系统自动判断），每个变量使用前必须被赋值 123456789counter = 100 # 整型变量#其他语言要指定变量类型:int counter = 100miles = 1000.0 # 浮点型变量name = &quot;runoob&quot; # 字符串# 输出变量print(counter)print(miles)print(name) 1.2 标准数据类型 数字(包括整型和浮点型) 字符串用单引号，或者双引号扩起来 1234s1 = &apos;abc&apos;s2 = &quot;abc&quot;print s1print s2 列表 集合类数据结构，类似数组。列表内数组的元素类型可以不同,用中括号定义 1l1 = [1,&quot;2a&quot;,3] 1234# 列生成表达式# 生成m*n行列表test = [[0 for i in range(m)] for j in range(n)] 元组 元组类似列表，但元组里的元素不可改变，但可以包含可变对象，例如列表。元组用小括号定义。 1tup1 = (&apos;physics&apos;, &apos;chemistry&apos;, 1997, 2000); 集合 是一种无序且不重复的序列，基本功能是成员包含测试或者去重，可以使用大括号或者set（）生成元组。 123a=&#123;1,2,3&#125;b=&#123;1,2,3,3&#125;#结果相同 字典 列表是有序对象的结合，字典是无序对象的集合。字典通过键值存取数据，列表通过位移偏移量存取。 a.键必须唯一 b.键必须是不可变数据类型 c.通过大括号和“：”来定义字典，或通过下标索引定义 12345tinydict = &#123;&apos;name&apos;: &apos;runoob&apos;,&apos;code&apos;:1, &apos;site&apos;: &apos;www.runoob.com&apos;&#125;dict = &#123;&#125;dict[&apos;one&apos;] = &quot;1 - 菜鸟教程&quot;dict[2] d. 其他构建字典的方法 12345678&gt;&gt;&gt;dict([(&apos;Runoob&apos;, 1), (&apos;Google&apos;, 2), (&apos;Taobao&apos;, 3)])&#123;&apos;Taobao&apos;: 3, &apos;Runoob&apos;: 1, &apos;Google&apos;: 2&#125; &gt;&gt;&gt; &#123;x: x**2 for x in (2, 4, 6)&#125;&#123;2: 4, 4: 16, 6: 36&#125; &gt;&gt;&gt; dict(Runoob=1, Google=2, Taobao=3)&#123;&apos;Taobao&apos;: 3, &apos;Runoob&apos;: 1, &apos;Google&apos;: 2&#125; 1.get()：获得键的值 2.items()：以列表方式获得字典 1.2.1 数据类型转换 不同数据类型之间，有的可以相互转换，有的不能,python常用自带函数进行转换，常见实例如下: 12345678910#1x = &apos;178&apos; #将字符串中的数字转换为整形y = int(x)# x = &apos;178a&apos;# y =int(x)# 报错,字符型不能转换为int#2x2 = &apos;abcd&apos;y2 =list(x2) #将字符串转换为list]]></content>
      <categories>
        <category>Python教程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.Python流程控制]]></title>
    <url>%2F2017%2F12%2F01%2FPython%2F2.%20Python%20%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[第二章 流程控制 Python原创教程，持续更新 2.1 简介流程控制指程序设计中语言最基础的运行流程,主要包括三种结构，顺序结构，分支结构，循环结构。 每种结构的实现语句在所有编程语言中都大致相同，主要是分支结构的if判断语句，和循环结构的while语句和for语句。 顺序结构 正常程序的顺序 分支结构 if判断语句 循环结构 while循环语句 for循环语句 2.2 if语句2.2.1 逻辑表达式 逻辑表达式是条件判断的方法。通过逻辑运算符两边数字等于、大于、小于或不等于等。若关系式条件成立，则返回bool值true，否则返回bool值false 逻辑运算符主要有: 123456789101112&gt; 大于# 5 &gt; 4# 条件成立，返回ture&lt; 小于# 5 &lt; 4# 条件不成立，返回false== 等于&gt;= 大于或等于&lt;= 小于或等于!= 不等于 2.2.2 if判断语句判断语句通过逻辑表达式(condition)的返回值，选择语句往返回值true处执行或false处执行 12345678910# 公式if 条件判断: 表达式 # 若 条件判断 返回值为true执行 表达式elif condition_2: statement_block_2 # 若condition_2返回值为true执行statement_block_2else: statement_block_3 # # 若condition_3返回值为flase执行statement_block_3 1234567# 示例var1 = 100if var1&gt;100: print (&quot;1 - if 表达式条件为 true&quot;) print (var1)else: print(var1+&quot;&lt;100&quot;) 2.3 while语句2.3.1 while循环 循环是重复执行某一段代码的程序语句，一般通过条件判断的结果执行循环，当条件为true时执行循环，当条件为false时循环结束。 python中没有do..while循环 1234567# 公式while 判断语句： 判断成立就执行循环语句#while惯例是提前定义一个变量，用于执行while的判断，并在循环语句中改变这个变量,以便判断语句能在循环一定次数后停止 12345678# 用while求一个1，2，3...100相加的结果sum = 0n = 1 # 提前定义的变量 while counter &lt;= 100: sum = sum + counter counter += 1 #通过自加改变这个变量,自加到100时循环停止 print(&quot;1 到 %d 之和为: %d&quot; % (n,sum)) 2.3.2 while..else循环123456count = 0while count &lt; 5: print (count, &quot; 小于 5&quot;) count = count + 1else: print (count, &quot; 大于或等于 5&quot;) while简单形式12345flag = 1 while (flag): print (&apos;欢迎访问菜鸟教程!&apos;) print (&quot;Good bye!&quot;) 2.4 for循环123456for &lt;variable&gt; in &lt;sequence&gt;: &lt;statements&gt;else: &lt;statements&gt;#&lt;variable&gt;是自定义的变量#&lt;sequence&gt;是一组数，可以是集合，列表，元祖等 range(函数):生成一组数 12345678range(10)#数字0-9range(10,15)#数字10-15range(10,100,5)#生成10-100的数，每个数相差(步调为)5 for实例 1234567# 1for x in [1,2,3,4,5]: print(x) # 2for y in range(10,100,5) print(x)]]></content>
      <categories>
        <category>Python教程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树&相关算法]]></title>
    <url>%2F2017%2F12%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%26%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[python实战基础《数据结构和算法》 类实现 定义类 123456789class Node(): def __init__(self,left=None,right=Node,data=0): self.left=left self.right=right self.data=data class Tree(): def __init__(self,root=0): self.root=root 生产一个二叉树 1234567891011n1=Node(data=1)n2=Node(n1,None,2) //左儿子n1，右没有儿子n2n3=Node(data=3)n4=Node(data=4)n5=Node(n3,n4,5)n6=Node(n2,n5,6)n7=Node(n6,None,7)n8=Node(data=8)root=Node(n7,n8,&apos;root&apos;)bt=Tree(root) 生成二叉树 123456789101112131415161718192021class BTree(): def __init__(self, root=0): self.root = root def is_empty(self): if self.root is None: return True else: return False def create(self): temp = input(&apos;enter a value:&apos;) if temp is &apos;#&apos;: return 0 treenode = Node(data=temp) if self.root is None: self.root = treenode treenode.left = self.create() treenode.right = self.create() 二叉树的遍历 前序遍历（根-左-右）a.递归123456def pre_order(tree): if tree==None: return 0 print(tree.data) pre_order(tree.left) pre_order(tree.right） b.用栈 12345678910111213def front_stack(tree): &quot;&quot;&quot;利用堆栈实现树的先序遍历&quot;&quot;&quot; if tree == None: return myStack = [] node = tree while node or myStack: while node: #从根节点开始，一直找它的左子树 pre(node.date), myStack.append(node) node = node.lchild node = myStack.pop() #while结束表示当前节点node为空，即前一个节点没有左子树了 node = node.rchild]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[glance]]></title>
    <url>%2F2017%2F12%2F01%2Fopenstack%2Fglance%2F</url>
    <content type="text"><![CDATA[openstack教程系列 glanceOpenStack Image Service（Glance）是IaaS的核心组件 1.简介 openstack目的是为用户创建一定配置需求的虚拟机 openstack用image创建以及重构虚拟机 openstack允许用户upload一定数量的image供创建虚拟机使用，至于image的数量，则有用户相关的tenant的quota来限定。 2.镜像状态 quewed:镜像的初始化状态 saving：数据上传的中间状态 active：镜像上传成功后的状态 -killed:错误镜像的状态，镜像不可读 -deleted：镜像不可用，且在一定时间后自动清空，类似“回收站”的文件 3.对比进程状态3.1 进程&amp;线程 进程（process） 和线程（thread）是操作系统的基本概念 计算机的核心是CPU，它承担了所有的计算任务。就像一座工厂，时刻在运行。 假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。 进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。 一个车间里，可以有很多工人。他们协同完成一个任务。线程就好比车间里的工人。一个进程可以包括多个线程。 车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。 相关知识 CPU中，进程是资源的最小单位，线程是执行的最小单位 一个线程使用某一共享内存时，其他线程必须等它结束，才能使用这一块内存。 一个防止共享内存使用出错的方法。是上锁，先用的线程上锁，后面的线程排队，等锁打开再进去。这就叫“互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。 线程池与上面的原理类似，只能同时n个线程使用，大于n的在后面排队。这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做“信号量”（Semaphore），用来保证多个线程不会互相冲突。 举例 开个QQ，开了一个进程；开了迅雷，开了一个进程。 在QQ的这个进程里，传输文字开一个线程、传输语音开了一个线程、弹出对话框又开了一个线程。 所以运行某个软件，相当于开了一个进程。在这个软件运行的过程里（在这个进程里），多个工作支撑的完成QQ的运行。 3.2 进程状态 参考：http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html]]></content>
      <categories>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>云平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高数基础]]></title>
    <url>%2F2017%2F11%2F22%2Fmath%2F%E9%AB%98%E6%95%B0%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[高数基础 导数a.y’=dy/dx b.y’的值为曲线在该点切线的斜率 极值在数学分析中，函数的最大值和最小值（最大值和最小值）被统称为极值（极数），是给定范围内的函数的最大值和最小值（本地 或相对极值）或函数的整个定义域（全局或绝对极值）。 a.求导数$f’(x)=0$的根（值） b.该点为极值（一定范围内） 单调性分为单调递增和单调递减 a.当f’(x)&gt;0$时，函数单调递增 b.当$f’(x)&lt;0$时，函数单调递减 ##连续性]]></content>
      <categories>
        <category>高数基础</category>
      </categories>
      <tags>
        <tag>公式</tag>
        <tag>高数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初等函数图形]]></title>
    <url>%2F2017%2F11%2F22%2Fmath%2F%E5%9B%BE%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[图形 1.直线a.斜率（切线）b.截距c.直线上的点d.平行，相交 2.圆锥曲线2.1椭圆椭圆（Ellipse）是平面内到定点F1、F2的距离之和等于常数（大于|F1F2|）的动点P的轨迹，F1、F2称为椭圆的两个焦点。其数学表达式为：|PF1|+|PF2|=2a（2a&gt;|F1F2|）。 a.设椭圆中心点为(h,k)椭圆公式为:$\frac{(x-h)^2}{a^2}+\frac{(y-k)^2}{b^2}=1$(焦点在a，b中的较大的点)b.其中$c^2=a^2-b^2$(2c为两焦点的距离，简称焦距)c.离心率e=c/a,其中$e\in(0,1)$,椭圆越扁，离心率越大; 2.2抛物线平面内，到定点与定直线的距离相等的点的轨迹叫做抛物线。其中定点叫抛物线的焦点，定直线叫抛物线的准线。 标准方程：特点： 2.3双曲线平面内与两个定点F1,F2的距离的差的绝对值等于一个常数(常数为2a，小于|F1F2|)的轨迹称为双曲线;平面内到两定点的距离差的绝对值为定长的点的轨迹叫做双曲线 a.│|MF1|-|MF2│|=2ab.准线 x=±$a^2$/c(焦点在x轴)c.实轴：曲线在焦点所在轴的交点虚轴：相对实轴的相对轴（无交点）（a-&gt;实轴点，b-&gt;虚轴点，c-&gt;焦点。）$a^2$+$b^2$=$c^2$d.渐近线：把双曲线等式右边的1换成0，就是渐进线 三角形s=1/2ah(a是底，h是高)s=1/2ac*sin b(b角对应的边为b) 正弦定理$\frac{sinA}{a}=\frac{sinB}{b}=\frac{sinC}{c}$其中a、b、c为边，A、B、C为边对应的角 余玹定理cos a= $\frac{a^2+b^2+c^2}{2bc} $ 最小正周期a.三角函数相加最小正周期是各个函数的周期的最小公倍数b.三角函数相乘时要化简]]></content>
      <categories>
        <category>高数基础</category>
      </categories>
      <tags>
        <tag>公式</tag>
        <tag>高数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率]]></title>
    <url>%2F2017%2F11%2F22%2Fmath%2F%E6%A6%82%E7%8E%87%2F</url>
    <content type="text"><![CDATA[概率 排列$ A_n^m = \frac{n!}{(n-m)!} $ 组合a. $ C_n^m = \frac{n!}{m!(n-m)!} $ b.$ C_n^m =C_n^t (t=n-m)$ c.$ C_{n+1}^m = C_n^m + C_n^{m-1}$ d.$ C_n^0+C_n^1+\ldots +C_n^n = 2^n $ e.$ C_n^m = \frac{A_n^m}{m!} $ 等差数列通项公式：$a_n = a_1 + (n-1)*d$求和公式：$S=\frac{n(a_1+a_n)}{2}$ 样本方差总体各单位变量值与其算术平均数的离差的平方，然后再对此变量取平均数，就叫做样本方差。样本方差用来表示一列数的变异程度。]]></content>
      <categories>
        <category>高数基础</category>
      </categories>
      <tags>
        <tag>公式</tag>
        <tag>高数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初等函数]]></title>
    <url>%2F2017%2F11%2F22%2Fmath%2F%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[初等函数 三角函数 常用公式$sina^2+cos^2=1 $ $tana^2+1=seca^2$ $1+cot^2=csca^2$ 角度转换／／2／／3／／4 奇偶关系除了$cos a$是偶函数外，其他三个是奇函数 二倍角关系／／二倍角1 和差角公式／／2 正切函数$\tan a$//正切 余切函数$cos a$／／余切 对数函数$y=\log_ax$／／ 幂函数$y=x^a $(a为有理数) y=x ,y=$x^3$为奇函数 y=$x^2$,y=$x^4$为偶函数 指数函数$y=a^x$(a为常数，且 a&gt;0,a$\neq$1)定义域为R,常数是指固定不变的数值]]></content>
      <categories>
        <category>高数基础</category>
      </categories>
      <tags>
        <tag>公式</tag>
        <tag>高数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游泳自学教程]]></title>
    <url>%2F2017%2F11%2F20%2F%E5%85%B3%E4%BA%8E%E6%B8%B8%E6%B3%B3%2F</url>
    <content type="text"><![CDATA[游泳的自学教程前言 ~游泳的前世今生感性地说游泳，除了星光和大海、就是对水的热爱。一种在船尾看着尾随鱼群想跳下去的冲动，一种搏击海浪的激情。 作为从小游泳游到大的人，可以说直到现在游的并不好。从小学花几百块和表哥参加师大的暑期的游泳班，到学校组织夏立营被同班的游泳好手淹个半死。很长时间并没有学会游泳。 直到有一天，在澄江。一个之前小时候双脚踩进青苔石块，就想伸手捞鱼的地方，一个后来偶然发现有着渔舟唱晚、天水一线的地方。瞬间学会了游泳。 可以说我对游泳的感觉是一直不会，一直再固执的坚持游，毕竟不太会游也可以游，主要目的是减肥。 总结下来，很多年因为偶然和勤奋等多种因素，还是长进不少。这里打算写一份课外教程，分享一些自学游泳的感悟。 !学游泳的keypointsa.学会总在一瞬间： 游泳很具实践性，也就是本能，这也是为什么小孩更容易学会的原因。当然，像我这样也属于后天才逐渐掌握，就是也有理论的作用。 对于成年人来学游泳，必要的是多游，多练，当你掌握了一个关键技巧后，你的游泳技术就会上一个台阶 b.必要的技巧: 1.水中平衡（这点非常重要）： 123是入门的标志，因为掌握水中的平衡是区别你在水中是**竖着**走还是**横着**走的关键，也是通俗说的是否会“换气”、和是否怕“淹水”等问题的解决的标志。 2.学青蛙或小狗一样在水中前进 12也是“蛙泳”和“自由泳”的学样式学法，通过根据动物在水中的动作，进行模仿学样，得到 **横着** 在水中前进的方法 3.改进姿势 123毕竟我们和动物结构是有区别的、动物的很多动作我们不能完全模仿，也不适合人，这时候就需要逐步“微调”，逐渐得到适合人且效率与舒适兼顾的游泳姿势。 4.体能 123这其实很好理解，也比较简单。就像跑步，体能不好，怎么跑？也是大多数热爱游泳的一个目的吧，锻炼身体，增强体能。 5.身体协调 1234这是一个调节，就是游泳中每个动作的改进和适应，需要身体其它部位的协调，这在游泳中显得特别突出。因为游泳是**全身性运动**，你手在动的时候其他部位也在动。有时你觉得手的姿势不对，你调整手的姿势，但是你之前的动作和身体其他部位的动作（例如腿部）动作是协调的。这时挑战需要特别注意身体协调的配套适应改进。 c.其他 我基本是自学的蛙泳和自由泳，蛙泳游的时间比较长，基本能保证正常速度在水中游蛙泳半个小时不会累。自由泳是研究生期间看一些教程和自己规划点练习学会的，前期游的不好，很累，现在能保证比蛙泳略快的前提下游20分钟不会感觉累。 在之后的时间，我会针对以上5点，把自己游泳的心得整理出来，作为自学游泳的一个教程，分享给想自学游泳或者准备自学游泳的同学们。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>运动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nova组件相关技术]]></title>
    <url>%2F2017%2F11%2F20%2Fopenstack%2Fnova%2F</url>
    <content type="text"><![CDATA[一、RabbitMQ个组件通过消息队列实现通讯 二、AMQP协议RabbiteMQ是其中一个实现1.多信道 2.异步 三层实现1.传输层帧处理、信道复用、错误检测、数据表示 2.会话层负责客户端至服务器的通讯，包括可靠性、同步机制、和错误处理 3.模型层定义一套命令，客户端使用这些命令来实现这些功能 对比TCP/IP五层协议1.物理层IEEE 802.1-802.2 2.数据链路层：PPPEthernet：局域网通信标准 3.网络层（关于路由）：IPARP:地址解析协议RARPICMP 4.传输层TCP:提供ip环境下的可靠传输UDP 5.应用层(表示层、会话层) HTTP FTP NFS SNMP SMTP:(simple mail transfer protocol),由源地址到目的地址的邮件传送规则 DNS：(domain namesystem),ip地址和域名映射的一个分布式数据库 Telnet 三、Nova-Scheduler过滤（filter）：过滤不能满足条件的节点 计算权值（weight）：通过“重要性”计算出哪个节点调度 类比学习《操作系统》中的进程调度1.什么是进程（与线程的区别） 2.进程的三种状态 3.进程调度的算法 a.先进先出 b.短进程优先 c.轮询(按钟表时间分配给进程)]]></content>
      <categories>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>云平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Devstack集成安装（ubuntu下）]]></title>
    <url>%2F2017%2F11%2F20%2Fopenstack%2FDevstack%2F</url>
    <content type="text"><![CDATA[Ubuntu 16.04下安装openstack教程（使用Devstack） 安装前的准备1.下载安装虚拟机vm 2.安装ubuntu16.04 3.安装git 1$ apt install git 一、基本步骤1.添加用户（Devstack要以非root用户运行，但需要sudo权限） 1$ sudo useradd -s /bin/bash -d /opt/stack -m stack //关于useradd命令的参数意义如下，供参考：1234567891011121314151617181920212223-c&lt;备注&gt;：加上备注文字。备注文字会保存在passwd的备注栏位中；**-d&lt;登入目录&gt;：指定用户登入时的启始目录；** -D：变更预设值；-e&lt;有效期限&gt;：指定帐号的有效期限； -f&lt;缓冲天数&gt;：指定在密码过期后多少天即关闭该帐号； -g&lt;群组&gt;：指定用户所属的群组； -G&lt;群组&gt;：指定用户所属的附加群组； **-m：自动建立用户的登入目录；** -M：不要自动建立用户的登入目录； -n：取消建立以用户名称为名的群组；-r：建立系统帐号； **-s：指定用户登入后所使用的shell；**-u：指定用户id。 2.给予stack用户sudo权限123$ echo &quot;stack ALL=(ALL) NOPASSWD: ALL&quot; | sudo tee /etc/sudoers.d/stack$ sudo su - stack//这里注意区别su -和su，带-是指切换用户的时候同时切换shell环境 3.下载Devstack 12$ git clone https://git.openstack.org/openstack-dev/devstack$ cd devstack 4.创建local.conf配置文件 用来预置openstack root密码注：conf读写权限默认无法写入，用chmod更改1234567$vi conf//以下写入conf[[local|localrc]]ADMIN_PASSWORD=secretDATABASE_PASSWORD=$ADMIN_PASSWORDRABBIT_PASSWORD=$ADMIN_PASSWORDSERVICE_PASSWORD=$ADMIN_PASSWORD 注：安装时刚开始会叫设置各组件安装密码，建议设置成一样的方便记忆 12./stack.sh//启动脚本开始安装 二、安装过程：安装大约持续一个小时。 之后组件keystone、glance、nova、cinder、neutron和 horizon安装成功。 客户机可访问外网，网络设置为Floating IPs。 可通过web浏览器访问horizon ，链接为http://9.115.112.111/dashboard 亦可访问keystone，链接为http://9.115.112.111/identity/ 可在shell中执行1source openrc 然后使用openstack命令行工具管理Devstack。 目录/opt/stack/tempest下存放了用来测试openstack平台的测试用例。 三、常用错误解决办法http://blog.csdn.net/xiongchun11/article/details/52679110 (遇到问题，把问题解决继续./stack.sh) 1.permission deniedsudo chown stack:stack 文件绝对路径 a.在安装各组建时容易报这个错误,把组建的文件名更改组和用户即可 2.devstack could not determine a suitable url这一般是ip问题，在配置文件conf中添加host_ip(内网) https://docs.openstack.org/devstack/latest/]]></content>
      <categories>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>云平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openStack网络组件]]></title>
    <url>%2F2017%2F11%2F20%2Fopenstack%2F%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[概述 一、发展历程第一个版本 nova-network123452010年openstack第一个版本网络组件为：nova-network功能：网络管理，包括ip分配、组网、以及网络模型等。 提供主要模型有： 1234567891011a.扁平网络(flat network)：创建虚拟主机时，组件会从预定子网中取一个空闲ip，并将网络信息写入虚拟主机的配置文件。* 在同一个子网中的虚拟主机可以相互ping通a+:带DHCP的flat newwork：在子网中自动为虚拟主机分配ip和物理地址b.vlan网络():vlan的意思是Virtual Local Area Network,就是虚拟局域网 第二个版本 Quantum随Openstack的Folsom版本发布 1.提供给租户api,使得租户能控制两层网络，管理ip地址 2.支持插件式网络组件，像Open vSwitch,Cisco,Linux Bridge,Nicira NVP 3.支持不同层的网络 4.支持隧道技术 隧道技术（Tunneling）是一种通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据（或负载）可以是不同协议的数据帧或包。隧道协议将其它协议的数据帧或包重新封装然后通过隧道发送。新的帧头提供路由信息，以便通过互联网传递被封装的负载数据。 5.支持3层转发和多重路由 6.提供负载均衡api（试用） 第三版 NeutronQuantum这名字侵权，更名为Neutron 1.提供更为稳定的负载均衡api 2.支持端到端的IPSec VPN 3.面向租户的防火墙服务注：截止2017.11,很多openstack云还在用nova-network，因为它简单，稳定。 Neutron构成1.APIa.插件的“零件” b.网络、子网、端口的查询 c.增加、删除、更新的操作 2.插件存储当前逻辑网络的配置信息 a.可以用SQLlite和MySQL b.存储逻辑网络和物理网络的对应关系 c.与交换机通信实现对应关系 3.Open vSmitch:开放虚拟交换 虚拟交换就是利用虚拟平台，通过软件的方式形成交换机部件。 跟传统的物理交换机相比，虚拟交换机同样具备众多优点，一是配置更加灵活。一台普通的服务器可以配置出数十台甚至上百台虚拟交换机，且端口数目可以灵活选择。 例如，VMware的ESX一台服务器可以仿真出248台虚拟交换机，且每台交换机预设虚拟端口即可达56个；二是成本更加低廉，通过虚拟交换往往可以获得昂贵的普通交换机才能达到的性能 OpenvSmitch需要访问的表： Tables_in_neutron agents allowedaddresspairs dnsnameservers externalnetworks extradhcpopts floatingips ipallocationpools ipallocations ipavailabilityranges networkdhcpagentbindings networks ovs_network_bindings ovs_tunnel_allocations ovs_tunnel_endpoints ovs_vlan_allocations portbindingports ports quotas routerl3agentbindings routerroutes routers securitygroupportbindings securitygrouprules securitygroups subnetroutes subnets Neutron 结构图 ovs &amp; ovnhttp://blog.csdn.net/cusor/article/details/18213977]]></content>
      <categories>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>云平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openStack集成安装]]></title>
    <url>%2F2017%2F11%2F20%2Fopenstack%2FopenStack%E9%9B%86%E6%88%90%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[官方文档https://docs.openstack.org/pike/ 使用Devstack组件keystone、glance、nova、cinder、neutron和 horizon安装成功 http://blog.csdn.net/ysbj123/article/details/77771065 http://blog.csdn.net/mygrus/article/details/53816022 使用Fuelhttps://www.cnblogs.com/dongdongwq/p/5627532.html http://blog.csdn.net/qq_21398167/article/details/51611487 使用Packstack (CentOS)https://wiki.openstack.org/wiki/Packstack https://github.com/openstack/packstack http://blog.csdn.net/violet_echo_0908/article/details/52049372 使用openshithttp://blog.csdn.net/justinshane/article/details/50097839]]></content>
      <categories>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>云平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Packstack集成安装(CentOS 7)]]></title>
    <url>%2F2017%2F11%2F20%2Fopenstack%2FPackstak%E9%9B%86%E6%88%90%E5%AE%89%E8%A3%85(CentOS)%2F</url>
    <content type="text"><![CDATA[Packstack 集成安装(CentOS 7)CentOS, Red Hat Enterprise Linux (RHEL)两个版本可用 安装前准备(部署在一台主机上)a.一键安装,首选保证centOS能上网 b.虚拟机主机硬件设置中cpu打开VT-X c.同步系统时间 d.虚拟机主机硬件设置内存8g以上 1.首先安装yum若报错：1Ropodate is over 2 weeks old 解决： 123456yum clean allyum updateyum makecache //将源更新保存至本地缓存 2.安装packstack源和命令12345$ sudo yum install -y http://rdo.fedorapeople.org/rdo-release.rpm//用于配置安装源$ sudo yum install -y openstack-packstack//安装packstack命令 3.安装1$ packstack --allinone 4.常见错误1.apply puppet controller.pp卡住 解决：同步系统时间 12345678$ yum instal ntp ntp date//安装网络时间协议$ ntpdate cn.pool.ntp.org// 同步系统时间$ hwclock --systohc//写入硬件（否则下次重启失效）]]></content>
      <categories>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>云平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[keystone(v3) 简介]]></title>
    <url>%2F2017%2F11%2F20%2Fopenstack%2Fkeystone%2F</url>
    <content type="text"><![CDATA[keystone(v3) 简介 核心概念User(用户):服务的用户，可以是人、系统或服务，只要是openstack服务的对象都可以称为用户。 Tenant(租户)：可以理解为人、项目或者组织拥有资源的集合，在一个租户中可以拥有很多个用户，这些用户可以根据权限划分使用租户的资源。 Role(角色)：用于分配操作的权限，角色可以指定给用户，用户会获得对应该角色的权限。 Token(认证)：指的是一串比特值或者字符串，用来作为访问资源的记号。token中含有可访问资源的范围 keystone交互过程 首先用户向Keystone提供自己的身份验证信息，如用户名和密码。Keystone 会从数据库中读取数据对其验证，如验证通过，会向用户返回一个 token，此后用户所有的请求都会使用该token进行身份验证。如用户向 Nova 申请虚拟机服务，nova 会将用户提供的 token 发给 Keystone 进行验证，Keystone会根据token判断用户是否拥有进行此项操作的权限，若验证通过那么nova会向其提供相对应的服务。其它组件和 Keystone 的交互也是如此。 在 Keystone V3 之前，用户的权限管理以每一个用户为单位，需要对每一个用户进行角色分配，并不存在一种对一组用户进行统一管理的方案，这给系统管理员带来了额外的工作和不便。此外，Keystone V3 之前的版本中，资源分配是以 Tenant 为单位的，这不太符合现实世界中的层级关系。如一个公司在 Openstack 中拥有两个不同的项目，他需要管理两个 Tenant 来分别对应这两个项目，并对这两个 Tenant 中的用户分别分配角色。 keystone v3为了更加符合现实世界和云服务的映射，将 Tenant 改为 Project 并在其上添加 Domain 的概念 graph TD A[Tenant] --&gt;|改为| B(Project) B --&gt; C(Domain) B --&gt; D(Group) graph LR; A–&gt;B; A–&gt;C; B–&gt;D; C–&gt;D; V3 利用 Domain 实现真正的多租户（multi-tenancy）架构，Domain 担任 Project 的高层容器。云服务的客户是 Domain 的所有者，他们可以在自己的 Domain 中创建多个 Projects、Users、Groups 和 Roles。通过引入 Domain，云服务客户可以对其拥有的多个 Project 进行统一管理，而不必再向过去那样对每一个 Project 进行单独管理。 域(Domain):比Project更高级的容器，云服务客服是Domain的拥有者，一个Domain可以创建多Project、Users、Groups和Roles。通过Domain对所拥有的多个Project统一管理，不必对每个Project单独管理。 组(Group):是一组User容器,通过给Group分配角色，在用一组的用户就有Group所有角色的权限 keystone v3 各组件关系 UUID FRENET]]></content>
      <categories>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>云平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql基础教程1]]></title>
    <url>%2F2017%2F11%2F09%2Fsql%2Fsql_1%2F</url>
    <content type="text"><![CDATA[针对常用命令直接实践掌握 一、基础命令1.启动登录12service mysqld start //启动mysqlmysql -u root -p password //登陆root password 2.建立新用户(grant命令)格式：grant all privileges on 数据库.* to 用户名@登录主机 identified by “密码”； 12grant all privileges on shopex.* to test@localhost identified by &quot;1234&quot;; 增加一个用户test密码为”1234”,让他只可以在localhost上登录，并可以对数据库Shopex进行所有的操作（localhost指本地主机，即MYSQL数据库所在的那台主机） 3.操作数据库1234567891011121314create database student_management;//创建数据库show databases;use student_management;show table;create table student_info(stu_id int,name varchar(8),sex varchar(4),class varchar(16));//创建student_info表create table teacher_info(tea_id int primary key,name varchar(8),sex varchar(4) check(sex=’男’ or sex=’女’),join_time date,nationality varchar(8) default ’汉族’)//主键、约束、默认值desc student_info;//查看表结构 二、对表数据操作1.增删改12345678insert into student_info values(20080201,’张帅’,’男’,’计算机软件’);//增加一行数据update student_info set class=’计算机软件’ where name=’王青’;//修改一行数据delete from student_info where name=’张玲’;//删除一行数据 2.查询1234567891011select * from student_info order by stu_id;//order by子句：按顺序排序select stu_id,class from student_info where name=’李飞’;//where子句：过滤记录select count(*) from student_info;//count()函数：计数select name from student_info where name like &apos;张%&apos;;//like操作符:模式（模糊）匹配,&quot;%&quot;符号用于在模式的前后定义通配符（缺省字母） 三、对表结构操作1234567891011121314151617181920alter table student_info add tel_num int(11);//添加字段alter table student_info change name stu_name varchar(8);//修改字段名称alter table student_info modify stu_id int primary key;//修改字段属性alter tavle student_info modify tel_num int(22);//同上alter table student_info drop column tel_num;//删除字段drop table course_info;//删除表drop database student_management;//删除数据库]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学公式]]></title>
    <url>%2F2017%2F11%2F08%2Fmath%2F%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Latex编辑方式 1.$\log_2 10$$\log_2 10$ 2.$\sin x$$\sin x$ 3.$\frac{7x+5}{1+y^2}$$\frac{7x+5}{1+y^2}$ 4.$s=\sum_1^n{n_i}$$s=\sum_1^n{n_i}$ 5.$\int_{1}^{a}$ $\int_{1}^{a}$ 6.$\infty$$\infty$ 7.$\sqrt[x+1]{x^2}$$\sqrt[x+1]{x^2}$ hexo配置方法a.直接在主题中的配置mathjax，把flase改为ture即可b.不用像网上说的那样安装math，更换渲染引擎，复杂且各种bug，归其原因：引擎和math包是安装在hexo下，但是hexo主题next已集成了math和引擎（就像两个配置文件，两个node.modules）,hexo安装的包理论上没什么用，除非不用next自带的,其他主题也是一样的道理。]]></content>
      <categories>
        <category>高数基础</category>
      </categories>
      <tags>
        <tag>公式</tag>
        <tag>高数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql_2]]></title>
    <url>%2F2017%2F11%2F07%2Fsql%2Fsql_2%2F</url>
    <content type="text"><![CDATA[查询_2 1. 聚合函数计算列中的值，返回一个单一的值 SUM() 求总和 MIN() 最小值 MAX() 最大值 AVG() 平均值 count() 返回行数 first() last() 2. join (inner join,left join,right join)12345SELECT Websites.id, Websites.name, access_log.count, access_log.dateFROM WebsitesINNER JOIN access_logON Websites.id=access_log.site_id;//把两张表拼起来查询 3. group by 语句结合聚合函数使用 12345678910SELECT site_id, SUM(access_log.count) AS numsFROM access_log GROUP BY site_id;//按某一字段，聚合其他字段数据后显示新表SELECT Websites.name,COUNT(access_log.aid) AS nums FROM access_logLEFT JOIN WebsitesON access_log.site_id=Websites.idGROUP BY Websites.name;// 4. having 子句1234567891011121314SELECT Websites.name, Websites.url, SUM(access_log.count) AS nums FROM (access_logINNER JOIN WebsitesON access_log.site_id=Websites.id)GROUP BY Websites.nameHAVING SUM(access_log.count) &gt; 200;//having的作用在于对group by后的数据进行筛选，类似where，而where不能用聚合函数 SELECT Websites.name, SUM(access_log.count) AS nums FROM WebsitesINNER JOIN access_logON Websites.id=access_log.site_idWHERE Websites.alexa &lt; 200 GROUP BY Websites.nameHAVING SUM(access_log.count) &gt; 200;]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于大学城 和 青春]]></title>
    <url>%2F2017%2F10%2F01%2F%E5%A4%A7%E5%AD%A6%E5%9F%8E%E4%B8%8E%E9%9D%92%E6%98%A5%2F</url>
    <content type="text"><![CDATA[关于大学城 和 青春 诗 &nbsp; 和 &nbsp; 远方&emsp;“你能上天时为什么不浪？“ ————《somebody sometime》 &emsp;&emsp;到重庆大学城不知不觉已经半年。说起大学城，基本每个城市都一样，隔一到两条街就是一个学校，是个有着无数且只有学校的地方。聊以慰藉的，是校里校外宽敞的公路，优美的绿化，还有一两个热闹的商街。。 &emsp;&emsp;当然，更多的是大面积未开发的区域，类似高速公路的环山的风景，还有一望无际类似田野的乡村，于是“城乡结合部”，“村里”这些描述偏僻的词语。 &emsp;&emsp;这让我想起一段往事，11年6月，我从本科毕业回到家乡，那时有一个叫呈贡的地方，偏僻，荒凉，同样被冠予“大学城”的绰号，当时朋友为了能在主城置换房产，专门去了大学城卖掉家里云大的职工房。当时去大学城的时候，朋友还说过一句话：“这鸟不拉屎的地方，站在隔壁山上都可以看到澄江。” &emsp;&emsp;后来，因为工作的原因，走过省内不少区县，普洱就去过不止一次，听着一两首民歌，绕山绕水，高高的山上走马棒。 &emsp;&emsp;有时，激情洋溢的内心也有梦想，高速边停车愿望，青春是否可以抛头颅，洒热血，建设家乡。 &emsp;&emsp;再后来，对大学城空旷和荒凉有了更明确的看法。城市要发展，也注定是一个缓慢的过程。 &emsp;&emsp;一代又一代的年轻人，大学不过就是人生的一段路，人生的起点。当我们站在大学城一望无际的土地上，是否会有对未来的憧憬而有点激情澎湃呢。 &emsp;&emsp;诚然，变革和发展必然伴随痛苦，在此为之无悔地奋斗，奉献青春，我觉得，是幸运地。脚下的土地，月光下天边的星空，会因我们的努力而改变。我们未来的时光，艰苦漫长，但不再迷茫。 &emsp;&emsp;这片土地伴随着你，无论好与坏，相聚离愁。 &emsp;&emsp;不如在这片土地，这段时光，不畏惧，不退缩，尽全力，做想做的事，做该做的梦。 &emsp;&emsp;终有一天，当你离开大学城时， 我想这就是对青春最好的注脚。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云平台]]></title>
    <url>%2F2017%2F10%2F01%2Fmd%E5%A4%B4%E9%83%A8%2F</url>
    <content type="text"></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>Youth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[about Markdown]]></title>
    <url>%2F2017%2F10%2F01%2Fabout%20markdown%2F</url>
    <content type="text"><![CDATA[Markdown 语法和 MWeb 写作使用说明Markdown 的设计哲学 Markdown 的目標是實現「易讀易寫」。不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。Markdown 的語法有個主要的目的：用來作為一種網路內容的寫作用語言。 本文约定如果有写 效果如下：， 在 MWeb 编辑状态下只有用 CMD + 4 或 CMD + R 预览才可以看效果。 标题Markdown 语法： 123# 第一级标题 `&lt;h1&gt;` ## 第二级标题 `&lt;h2&gt;` ###### 第六级标题 `&lt;h6&gt;` 效果如下： 第一级标题 &lt;h1&gt;第二级标题 &lt;h2&gt;第六级标题 &lt;h6&gt;强调Markdown 语法： 12345*这些文字会生成`&lt;em&gt;`*_这些文字会生成`&lt;u&gt;`_**这些文字会生成`&lt;strong&gt;`**__这些文字会生成`&lt;strong&gt;`__ 在 MWeb 中的快捷键为： CMD + U、CMD + I、CMD + B效果如下： 这些文字会生成&lt;em&gt;这些文字会生成&lt;u&gt; 这些文字会生成&lt;strong&gt;这些文字会生成&lt;strong&gt; 换行四个及以上空格加回车。如果不想打这么多空格，只要回车就为换行，请勾选：Preferences - Themes - Translate newlines to &lt;br&gt; tags 列表无序列表Markdown 语法： 1234* 项目一 无序列表 `* + 空格键`* 项目二* 项目二的子项目一 无序列表 `TAB + * + 空格键`* 项目二的子项目二 在 MWeb 中的快捷键为： Option + U效果如下： 项目一 无序列表 * + 空格键 项目二 项目二的子项目一 无序列表 TAB + * + 空格键 项目二的子项目二 有序列表Markdown 语法： 123451. 项目一 有序列表 `数字 + . + 空格键`2. 项目二 3. 项目三1. 项目三的子项目一 有序列表 `TAB + 数字 + . + 空格键`2. 项目三的子项目二 效果如下： 项目一 有序列表 数字 + . + 空格键 项目二 项目三 项目三的子项目一 有序列表 TAB + 数字 + . + 空格键 项目三的子项目二 任务列表（Task lists）Markdown 语法： 12- [ ] 任务一 未做任务 `- + 空格 + [ ]`- [x] 任务二 已做任务 `- + 空格 + [x]` 效果如下： 任务一 未做任务 - + 空格 + [ ] 任务二 已做任务 - + 空格 + [x] 图片Markdown 语法： 12![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif)格式: ![Alt Text](url) Control + Shift + I 可插入Markdown语法。如果是 MWeb 的文档库中的文档，还可以用拖放图片、CMD + V 粘贴、CMD + Option + I 导入这三种方式来增加图片。效果如下： MWeb 引入的特别的语法来设置图片宽度，方法是在图片描述后加 -w + 图片宽度 即可，比如说要设置上面的图片的宽度为 140，语法如下： 链接Markdown 语法： 123email &lt;example@example.com&gt;[GitHub](http://github.com)自动生成连接 &lt;http://www.github.com/&gt; Control + Shift + L 可插入Markdown语法。如果是 MWeb 的文档库中的文档，拖放或CMD + Option + I 导入非图片时，会生成连接。效果如下： Email 连接： &#101;&#x78;&#x61;&#x6d;&#x70;&#108;&#x65;&#64;&#x65;&#120;&#97;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;连接标题Github网站自动生成连接像： http://www.github.com/ 这样 区块引用Markdown 语法： 123某某说:&gt; 第一行引用&gt; 第二行费用文字 CMD + Shift + B 可插入Markdown语法。效果如下： 某某说: 第一行引用第二行费用文字 行内代码Markdown 语法： 1像这样即可：`&lt;addr&gt;` `code` CMD + K 可插入Markdown语法。效果如下： 像这样即可：&lt;addr&gt; code 多行或者一段代码Markdown 语法： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; CMD + Shift + K 可插入Markdown语法。效果如下： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; 顺序图或流程图Markdown 语法： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 &lt;div id=&quot;flowchart-0&quot; class=&quot;flow-chart&quot;&gt;&lt;/div&gt; 效果如下（ Preferences - Themes - Enable sequence &amp; flow chart 才会看到效果 ）： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 更多请参考：http://bramp.github.io/js-sequence-diagrams/, http://adrai.github.io/flowchart.js/ 表格Markdown 语法： 1234第一格表头 | 第二格表头--------- | -------------内容单元格 第一列第一格 | 内容单元格第二列第一格内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格 效果如下： 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格 删除线Markdown 语法： 加删除线像这样用： 删除这些 效果如下： 加删除线像这样用： 删除这些 分隔线以下三种方式都可以生成分隔线： 效果如下： MathJaxMarkdown 语法： 12345678块级公式：$$ x = \dfrac&#123;-b \pm \sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; $$\\[ \frac&#123;1&#125;&#123;\Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123;\frac25 \pi&#125;&#125; =1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-6\pi&#125;&#125;&#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125; &#123;1+\ldots&#125; &#125; &#125; &#125; \\]行内公式： $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$ 效果如下（Preferences - Themes - Enable MathJax 才会看到效果）： 块级公式：$$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$ \[ \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} =1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}}{1+\frac{e^{-8\pi}} {1+\ldots} } } } \] 行内公式： $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$ 脚注（Footnote）Markdown 语法： 1这是一个脚注：[^sample_footnote] 效果如下： 这是一个脚注：^sample_footnote 注释和阅读更多 Actions-&gt;Insert Read More Comment 或者 Command + .注 阅读更多的功能只用在生成网站或博客时，插入时注意要后空一行。 TOCMarkdown 语法： 1[TOC] 效果如下： [TOC] st=>start: 开始 e=>end: 结束 op=>operation: 我的操作 cond=>condition: 确认？ st->op->cond cond(yes)->e cond(no)->op{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);st=>start: 开始 e=>end: 结束 op=>operation: 我的操作 cond=>condition: 确认？ st->op->cond cond(yes)->e cond(no)->op{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-1-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-1", options);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment othersBase (top) 佐天泪子 (xiān qún kuáng mó) 超電磁砲 (レールガン) flow 公式块级公式：$$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$ \[ \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} =1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}}{1+\frac{e^{-8\pi}} {1+\ldots} } } } \] 头部要有mathjax: true 行内公式： $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$ sequence123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 st=>start: 开始 e=>end: 结束 op=>operation: 我的操作 cond=>condition: 确认？ st->op->cond cond(yes)->e cond(no)->op{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <tags>
        <tag>MD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.2 列表详解]]></title>
    <url>%2F2017%2F02%2F01%2FPython%2F1.1%20%E5%88%97%E8%A1%A8-%E7%B4%A2%E5%BC%95%E5%92%8C%E5%88%87%E7%89%87%2F</url>
    <content type="text"><![CDATA[继第一章 1.2.2 列表详解列表是python中最常见的数据结构，类似数组。其中一些自带的函数具有代表性，用于其他各类数据结构中。 包括列表的添加，删除，索引，切片 123456789101112131415161718192021222324252627la = [1,&apos;a&apos;,&#123;&apos;a&apos;&#125;,&#123;1:&apos;a&apos;&#125;,True,[1,2],1]#常见操作len(la)la.count(&apos;1&apos;)la.index(&apos;a&apos;)la+lala*3#添加删除操作la.append(&apos;b&apos;)la.extend(&apos;abc&apos;)la.insert(3,&apos;xxx&apos;)la.remove(1)la.remove(la[0])la.pop()del la[2] 其中切片和索引是列表操作的精髓，其同样可以用到字符串和很多类似的一维数据结构中 1234567891011121314151617la[0] #第1个元素la[1]la[-1] #倒数第1个元素la[2:5] #第2到第4个元素la[2:] #第2到最后一个元素(终点默认，不包括最后一个)la[:5] #第1个元素到最后1个元素(起点默认)la[2:6:2] #2到5个元素，步跳为2la[::2] #第一个到最后一个元素，步跳为2(起点和终点默认)la[::-1] #列表反转，步跳为-1 列表推导，一种通过循环来定义数据的方式 123a = [1,2,3]b = [a*60 for i in a]]]></content>
      <categories>
        <category>Python教程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有生以来第一次被如此期待]]></title>
    <url>%2F2011%2F03%2F27%2F%E7%81%8C%E7%AF%AE%E9%AB%98%E6%89%8B%E8%AF%BB%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[有生以来第一次被如此期待评灌篮高手 SLAM DUNK完全版————《why walk when you can fly》 &emsp;&emsp;又一次重温经典，又一次的感动。。 &emsp;&emsp;我可以感觉到血液的沸腾。。 &emsp;&emsp;&emsp;&emsp;我的思绪回到了小学。。。 &emsp;&emsp;记得第一次看灌篮高手时，我尽然分错了主角，把仙道当成了主角，不过那时还是很欣赏樱木、流川枫，他们都很有天分。可是就不明白为什么他们非要互相敌对，后来明白的时候，真期待他们的联手，相信他们的联手绝对是一个黄金搭档，就像乔丹和皮蓬一样。 &emsp;&emsp;后来迷上了灌篮高手，当然也就分清主角了。每日都要守在电视机旁观看，我好像进入了电视中，和他们活在了一起，我迷失在现实世界中，而到了他们的世界。 &emsp;&emsp;我把周围的一切、同学、朋友 都按照他们的外貌、性格和感觉分成动画中的角色。 &emsp;&emsp;也因为灌篮高手，我打了几年篮球， &emsp;&emsp;小学生的篮球可能就是随便玩玩，没什么技术含量。 &emsp;&emsp;但是我很怀念那段时间，我们十几个同学周末的时候一起去打篮球的场景， &emsp;&emsp;那时候，灌篮高手很火，甚至我们的班主任女老师 也非常喜欢看灌篮高手。 我们同学打篮球的时候，也会把自己当成 动画中的角色。 当然多数都是自称 天才，樱木或者流川枫， 我在篮球场的时候，真的把自己当成了他们。 我幻想着自己有一天会成为世界篮球界的焦点，说不定我真是一个篮球天才呢。 就像我现在一样，当我看越狱的那段时间，我多数时间是把自己想象成 迈克尔-斯科菲尔德，我的外貌变成了他的，我想象自己用他的眼睛来看待这个世界。 时间流逝、几年没动过篮球，这个梦也深深的埋在了我的心里的一个角落。我有点害怕去寻找他，我不敢正视这个梦想。 就像我以前提到过，我们看电影、动画、小说，多数是为了满足我们潜意识的需要。现实中做不到，就在这些地方寻求。 正因如此，我更加迷恋灌篮高手了， 我不知道，他们是因果关系，还是相等关系。 每当我感到空虚失落的时候，就想重温一下《灌篮高手》 被如此期待……是有生以来……第一次。。 这是我们的天才选手—樱木花道 在全国大赛中对决 山王时，被安西教练委以重任时说的一句话（你是我们反败为胜的王牌！） 短短的几分钟，太多的经典镜头， 记得，樱木开始打篮球，并不是喜欢篮球运动，相反他还很讨厌篮球，也正因为讨厌，才和队长赤木有了一场精彩对决（哈哈，我想到了 赤木裤子被扒下的场景） 但是，在对决山王的时候，樱木为了抢下一个要落入边界的球，飞身跳过去，身体砸在了桌子上， 可是为这一球，差点断送了 樱木的 篮球生涯。 樱木感觉到了背部的疼痛， 樱木陷入了回想，他的第一次比赛，和赤木的对决、两万球特训，这些场景在樱木的脑海里回荡。 樱木站起来了，来到了晴子的身旁，说出了他对篮球的喜爱 “我非常喜欢，这次不是说谎” 故事结尾，也成全了我们大多数人的心愿，看到了 樱木 和 流川枫的 联手。 因为他们的联手最后才赢得胜利，完美绝杀山王。比分79-78 黄金搭档诞生的时刻。 故事结束了，我抑制不了我的情绪，写下此文….]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
